// *******************************
// include script dnd/jquery.client.js
(function() {
	
	var BrowserDetect = {
		init: function () {
			this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
			this.version = this.searchVersion(navigator.userAgent)
				|| this.searchVersion(navigator.appVersion)
				|| "an unknown version";
			this.OS = this.searchString(this.dataOS) || "an unknown OS";
		},
		searchString: function (data) {
			for (var i=0;i<data.length;i++)	{
				var dataString = data[i].string;
				var dataProp = data[i].prop;
				this.versionSearchString = data[i].versionSearch || data[i].identity;
				if (dataString) {
					if (dataString.indexOf(data[i].subString) != -1)
						return data[i].identity;
				}
				else if (dataProp)
					return data[i].identity;
			}
		},
		searchVersion: function (dataString) {
			var index = dataString.indexOf(this.versionSearchString);
			if (index == -1) return;
			return parseFloat(dataString.substring(index+this.versionSearchString.length+1));
		},
		dataBrowser: [
			{
				string: navigator.userAgent,
				subString: "Chrome",
				identity: "Chrome"
			},
			{ 	string: navigator.userAgent,
				subString: "OmniWeb",
				versionSearch: "OmniWeb/",
				identity: "OmniWeb"
			},
			{
				string: navigator.vendor,
				subString: "Apple",
				identity: "Safari",
				versionSearch: "Version"
			},
			{
				prop: window.opera,
				identity: "Opera"
			},
			{
				string: navigator.vendor,
				subString: "iCab",
				identity: "iCab"
			},
			{
				string: navigator.vendor,
				subString: "KDE",
				identity: "Konqueror"
			},
			{
				string: navigator.userAgent,
				subString: "Firefox",
				identity: "Firefox"
			},
			{
				string: navigator.vendor,
				subString: "Camino",
				identity: "Camino"
			},
			{		// for newer Netscapes (6+)
				string: navigator.userAgent,
				subString: "Netscape",
				identity: "Netscape"
			},
			{
				string: navigator.userAgent,
				subString: "MSIE",
				identity: "Explorer",
				versionSearch: "MSIE"
			},
			{
				string: navigator.userAgent,
				subString: "Gecko",
				identity: "Mozilla",
				versionSearch: "rv"
			},
			{ 		// for older Netscapes (4-)
				string: navigator.userAgent,
				subString: "Mozilla",
				identity: "Netscape",
				versionSearch: "Mozilla"
			}
		],
		dataOS : [
			{
				string: navigator.platform,
				subString: "Win",
				identity: "Windows"
			},
			{
				string: navigator.platform,
				subString: "Mac",
				identity: "Mac"
			},
			{
				string: navigator.userAgent,
				subString: "iPhone",
				identity: "iPhone/iPod"
		    },
			{
				string: navigator.platform,
				subString: "Linux",
				identity: "Linux"
			}
		]
	
	};
	
	BrowserDetect.init();
	
	window.$.client = { os : BrowserDetect.OS, browser : BrowserDetect.browser };
	
})();

// *******************************
// include script dnd/jquery.dnd-file-upload.js
//********************************************************
// JQuery wrapper to manage File upload via Drag and Drop
//
// Base code comes from https://github.com/pangratz/dnd-file-upload/network
//

if (!log) {
  log = function (logMsg) {
    // console && console.log(logMsg);
  }
}

(function ($) {

  var sendingRequestsInProgress = false;
  var tryToUploadDirectoryContent = false;
  var uploadStack = new Array();
  var uploadIdx = 0;
  var nbDropFilesToProcess = 0;
  var nbUploadInprogress = 0;
  var completedUploads = new Array();
  var currentDropZone;


  $.fn.dropzone = function (options, loadAlreadyUploadedFiles) {

    // Extend our default options with those provided.
    var opts = jQuery.extend({}, $.fn.dropzone.defaults, options);
    this.data("opts", opts);

    var id = this.attr("id");
    var dropzone = document.getElementById(id);

    if (window.$.client.browser == "Safari" && window.$.client.os == "Windows") {
      var fileInput = jQuery("<input>");
      fileInput.attr({
        type: "file"
      });
      fileInput.bind("change", function (event) {
        change(event, opts)
      });
      fileInput.css({'opacity': '0', 'width': '100%', 'height': '100%'});
      fileInput.attr("multiple", "multiple");
      fileInput.click(function () {
        return false;
      });
      this.append(fileInput);
    } else {
      dropzone.addEventListener("drop", function (event) {
        drop(event, opts);
      }, true);
      var jQueryDropzone = jQuery("#" + id);
      jQueryDropzone.bind("dragenter", function (event) {
        dragenter(event, jQueryDropzone, opts);
      });
      jQueryDropzone.bind("dragover", dragover);
    }

    // load already uploaded files for this batch
    if (loadAlreadyUploadedFiles) {
      var targetUrl = opts.url;
      if (targetUrl.indexOf("/", targetUrl.length - 1) == -1) {
        targetUrl = targetUrl + "/";
      }
      targetUrl = targetUrl + "batch/files/" + opts.handler.batchStarted();
      jQuery.ajax({
        type: 'GET',
        contentType: 'application/json+nxrequest',
        url: targetUrl,
        timeout: 10000
      }).done(function (data) {
          for (var i = 0, len = data.length; i < len; i++) {
            opts.handler.uploadStarted(i, data[i]);
            opts.handler.uploadFinished(i, data[i], null);
          }
          uploadIdx = data.length
        });
    }

    return this;
  };

  $.fn.dropzone.defaults = {
    url: "",
    method: "POST",
    numConcurrentUploads: 5,
    // define if upload should be triggered directly
    directUpload: true,
    // update upload speed every second
    uploadRateRefreshTime: 1000,
    // time to enable extended mode
    extendedModeTimeout: 1500,
    // http requests timeout
    uploadTimeout: 30000,
    execTimeout: 30000,
    handler: {
      // invoked when new files are dropped
      batchStarted: function () {
        return "X"
      },
      // invoked when the upload for given file has been started
      uploadStarted: function (fileIndex, file) {
      },
      // invoked when the upload for given file has been finished
      uploadFinished: function (fileIndex, file, time) {
      },
      // invoked when the progress for given file has changed
      fileUploadProgressUpdated: function (fileIndex, file, newProgress) {
      },
      // invoked when the upload speed of given file has changed
      fileUploadSpeedUpdated: function (fileIndex, file, KBperSecond) {
      },
      // invoked when all files have been uploaded
      batchFinished: function (batchId) {
      },
      // invoked to enable Extended mode
      enableExtendedMode: function (id) {
        console.log('Enable extended mode for zone ' + id)
      }
    }
  };

  function dragenter(event, zone, opts) {

    var id = zone.attr('id');

    log("dragenter on zone " + id);
    zone.addClass("dropzoneTarget");
    event.stopPropagation();
    event.preventDefault();

    var dragoverTimer = zone.data("dragoverTimer");
    if (!dragoverTimer && opts.extendedModeTimeout > 0) {
      dragoverTimer = window.setTimeout(function () {
        opts.handler.enableExtendedMode(id);
      }, opts.extendedModeTimeout);
      zone.data("dragoverTimer", dragoverTimer);
    }
    currentDropZone = zone;
    applyOverlay(zone, opts);
    return false;
  }

  function dragleave(event, id) {
    var zone = jQuery("#" + id);
    zone.removeClass("dropzoneTarget");
    var dragoverTimer = zone.data("dragoverTimer");
    if (dragoverTimer) {
      window.clearTimeout(dragoverTimer);
      zone.removeData("dragoverTimer");
    }
    return false;
  }

  function dragover(event) {
    event.stopPropagation();
    event.preventDefault();
    return false;
  }

  function getDirectoryEntries(directoryReader, opts) {
    nbDropFilesToProcess += 1;
    var readEntries = function () {
      directoryReader.readEntries(function (results) {
        if (!results.length) {
          processFileEntry(null, opts);
        } else {
          nbDropFilesToProcess += (results || []).length - 1;
          for (var i = 0; i < (results || []).length; i++) {
            if (results[i].isDirectory) {
              getDirectoryEntries(results[i].createReader(), opts);
            } else {
              results[i].file(function (f) {
                processFileEntry(f, opts);
              }, function (e) {
                log(e);
              });
            }
          }
          readEntries();
        }
      }, function (e) {
        log(e)
      });
    };
    readEntries();
  }

  function processFileOrFolderEntryAsync(fileOb, opts, fileCB, folderCB, transferItem) {
    // filter Folders from dropped content
    // Folder size is 0 under Win / %4096 under Linux / variable under MacOS
    if (!fileOb.type && fileOb.size < (4096 * 4 + 1)) {
      try {
        // need to test the file by reading it ...
        var reader = new FileReader();
        reader.onerror = function (e) {
          folderCB(fileOb, opts, transferItem);
        };
        reader.onabort = function (e) {
          folderCB(fileOb, opts, transferItem);
        };
        reader.onload = function (e) {
          fileCB(fileOb, opts);
        };
        reader.readAsBinaryString(fileOb);
      } catch (err) {
        folderCB(fileOb, opts, transferItem);
      }
    } else {
      fileCB(fileOb, opts);
    }
  }

  function cancelUploadIfNoValidFileWasDropped(opts) {
    if (uploadStack.length == 0 && uploadIdx == 0 && nbDropFilesToProcess == 0) {
      opts.handler.cancelUpload();
      if (currentDropZone) {
        var zone = jQuery("#" + currentDropZone.attr("id"));
        currentDropZone = null;
        dragleave(null, zone.attr("id"));
        zone.removeClass("dropzoneTarget");
        zone.bind("dragenter", function (zone, opts) {
          return function (event) {
            dragenter(event, zone, opts);
          }
        }(zone, opts));
      }
    }
  }

  function processFileEntry(cfile, opts) {
    nbDropFilesToProcess--;
    if (cfile) {
      uploadStack.push(cfile);
    }
    if (opts.directUpload && !sendingRequestsInProgress && uploadStack.length > 0) {
      uploadFiles(opts);
    } else {
      cancelUploadIfNoValidFileWasDropped(opts);
    }
  }

  function processFolderEntry(cfolder, opts, folderEntry) {
    if (tryToUploadDirectoryContent && folderEntry) {
      var directoryReader = folderEntry.createReader();
      if (directoryReader) {
        getDirectoryEntries(directoryReader, opts);
      }
    } else {
      nbDropFilesToProcess--;
      log("skipping folder");
    }
    cancelUploadIfNoValidFileWasDropped(opts);
  }

  function drop(event, opts) {
    event.preventDefault();
    var files = event.dataTransfer.files;
    nbDropFilesToProcess += files.length;
    for (var i = 0; i < files.length; i++) {
      var cfile = files[i];
      var folderEntry;
      if (event.dataTransfer.items && event.dataTransfer.items[i].webkitGetAsEntry) {
        folderEntry = event.dataTransfer.items[i].webkitGetAsEntry();
      }
      processFileOrFolderEntryAsync(cfile, opts, processFileEntry, processFolderEntry, folderEntry);
    }
    return false;
  }

  function applyOverlay(zone, opts) {
    log("apply Overlay on zone " + zone.attr("id"));
    zone.addClass("dropzoneTarget");
    if (jQuery.browser.mozilla && jQuery.browser.version.startsWith("1.")) {
      // overlay does break drop event catching in FF 3.6 !!!
      zone.bind("dragleave", function (event) {
        removeOverlay(event, null, zone, opts);
      });
    } else {
      // Webkit and FF4 => use Overlay
      var overlay = jQuery("<div></div>");
      overlay.addClass("dropzoneTargetOverlay");
      zone.append(overlay);
      resizeOverlay(zone);
      overlay.bind("dragleave", function (event) {
        removeOverlay(event, overlay, zone, opts);
      });
      zone.unbind("dragenter");
      log("overlay applied");
    }
  }

  function resizeOverlay(dropZone) {
    dropZone = jQuery(dropZone)
    dropZone.find(".dropzoneTargetOverlay").each(function () {
      var overlay = jQuery(this);
      overlay.css(dropZone.position());
      var computedWidth = dropZone.width();
      computedWidth += parseInt(dropZone.css('padding-right'), 10);
      computedWidth += parseInt(dropZone.css('padding-left'), 10);
      computedWidth += parseInt(dropZone.css('margin-right'), 10);
      computedWidth += parseInt(dropZone.css('margin-left'), 10);
      overlay.width(computedWidth);

      var computedHeight = dropZone.height();
      computedHeight += parseInt(dropZone.css('padding-top'), 10);
      computedHeight += parseInt(dropZone.css('padding-bottom'), 10);
      computedHeight += parseInt(dropZone.css('margin-top'), 10);
      computedHeight += parseInt(dropZone.css('margin-bottom'), 10);
      overlay.height(computedHeight);
    })
  }

  function removeOverlay(event, overlay, zone, opts) {
    zone.removeClass("dropzoneTarget");
    if (overlay != null) {
      overlay.unbind();
      overlay.css("display", "none");
      overlay.remove();
      window.setTimeout(function () {
        zone.bind("dragenter", function (event) {
          dragenter(event, zone, opts);
        });
      }, 100);
      currentDropZone = null;
    }
    var dragoverTimer = zone.data("dragoverTimer");
    if (dragoverTimer) {
      window.clearTimeout(dragoverTimer);
      zone.removeData("dragoverTimer");
    }
    return false;
  }

  function uploadFiles(opts) {

    if (nbUploadInprogress >= opts.numConcurrentUploads) {
      sendingRequestsInProgress = false;
      log("delaying upload for next file(s) " + uploadIdx + "+ since there are already " + nbUploadInprogress + " active uploads");
      return;
    }

    var batchId = opts.handler.batchStarted();
    sendingRequestsInProgress = true;

    while (uploadStack.length > 0) {
      var file = uploadStack.shift();
      // create a new xhr object
      var xhr = new XMLHttpRequest();
      var upload = xhr.upload;
      upload.fileIndex = uploadIdx + 0;
      upload.fileObj = file;
      upload.downloadStartTime = new Date().getTime();
      upload.currentStart = upload.downloadStartTime;
      upload.currentProgress = 0;
      upload.startData = 0;
      upload.batchId = batchId;

      // add listeners
      upload.addEventListener("progress", function (event) {
        progress(event, opts)
      }, false);

      // The "load" event doesn't work correctly on WebKit (Chrome, Safari),
      // it fires too early, before the server has returned its response.
      // still it is required for Firefox
      if (navigator.userAgent.indexOf('Firefox') > -1) {
        upload.addEventListener("load", function (event) {
          log("trigger load");
          log(event);
          load(event.target, opts)
        }, false);
      }

      // on ready state change is not fired in all cases on webkit
      // - on webkit we rely on progress lister to detected upload end
      // - but on Firefox the event we need it
      xhr.onreadystatechange = (function (xhr, opts) {
        return function () {
          readyStateChange(xhr, opts)
        }
      })(xhr, opts);

      // propagate callback
      upload.uploadFiles = uploadFiles;

      // compute timeout in seconds and integer
      uploadTimeoutS = 5 + (opts.uploadTimeout / 1000) | 0;

      var targetUrl = opts.url;
      if (targetUrl.indexOf("/", targetUrl.length - 1) == -1) {
        targetUrl = targetUrl + "/";
      }
      targetUrl = targetUrl + "batch/upload";

      log("starting upload for file " + uploadIdx);
      xhr.open(opts.method, targetUrl);
      xhr.setRequestHeader("Cache-Control", "no-cache");
      xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      xhr.setRequestHeader("X-File-Name", encodeURIComponent(file.name));
      xhr.setRequestHeader("X-File-Size", file.size);
      xhr.setRequestHeader("X-File-Type", file.type);
      xhr.setRequestHeader("X-Batch-Id", batchId);
      xhr.setRequestHeader("X-File-Idx", uploadIdx);

      xhr.setRequestHeader('Nuxeo-Transaction-Timeout', uploadTimeoutS);
      nbUploadInprogress++;

      opts.handler.uploadStarted(uploadIdx, file);
      uploadIdx++;

      // resize the overlay
      jQuery(".dropzoneTarget").each(function () {
        resizeOverlay(this);
      });

      xhr.send(file);

      if (nbUploadInprogress >= opts.numConcurrentUploads) {
        sendingRequestsInProgress = false;
        log("delaying upload for next file(s) " + uploadIdx + "+ since there are already " + nbUploadInprogress + " active uploads");
        return;
      }
    }
    sendingRequestsInProgress = false;
  }

  function readyStateChange(xhr, opts) {
    var upload = xhr.upload;
    log("readyStateChange event on file upload " + upload.fileIndex + " (state : " + xhr.readyState + ")");
    if (xhr.readyState == 4) {
      if (xhr.status == 200) {
        load(upload, opts);
      } else {
        log("Upload failed, status: " + xhr.status);
      }
    }
  }

  function load(upload, opts) {
    var fileIdx = upload.fileIndex;
    log("Received loaded event on  file " + fileIdx);
    if (completedUploads.indexOf(fileIdx) < 0) {
      completedUploads.push(fileIdx);
    } else {
      log("Event already processsed for file " + fileIdx + ", exiting");
      return;
    }
    var now = new Date().getTime();
    var timeDiff = now - upload.downloadStartTime;
    opts.handler.uploadFinished(upload.fileIndex, upload.fileObj, timeDiff);
    log("upload of file " + upload.fileIndex + " completed");
    nbUploadInprogress--;
    if (!sendingRequestsInProgress && uploadStack.length > 0 && nbUploadInprogress < opts.numConcurrentUploads) {
      // restart upload
      log("restart pending uploads");
      upload.uploadFiles(opts);
    }
    else if (nbUploadInprogress == 0) {
      opts.handler.batchFinished(upload.batchId);
    }
  }

  function progress(event, opts) {
    log(event);
    if (event.lengthComputable) {
      var percentage = Math.round((event.loaded * 100) / event.total);
      if (event.target.currentProgress != percentage) {

        log("progress event on upload of file " + event.target.fileIndex + " --> " + percentage + "%");

        event.target.currentProgress = percentage;
        opts.handler.fileUploadProgressUpdated(event.target.fileIndex, event.target.fileObj, event.target.currentProgress);

        var elapsed = new Date().getTime();
        var diffTime = elapsed - event.target.currentStart;
        if (diffTime >= opts.handler.uploadRateRefreshTime) {
          var diffData = event.loaded - event.target.startData;
          var speed = diffData / diffTime; // in KB/sec

          opts.handler.fileUploadSpeedUpdated(event.target.fileIndex, event.target.fileObj, speed);

          event.target.startData = event.loaded;
          event.target.currentStart = elapsed;
        }
        if (event.loaded == event.total) {
          log("file " + event.target.fileIndex + " detected upload complete");
          // having all the bytes sent to the server does not mean the server did actually receive everything
          // but since load event is not reliable on Webkit we need this
          // window.setTimeout(function(){load(event.target, opts);}, 5000);
        } else {
          log("file " + event.target.fileIndex + " not completed :" + event.loaded + "/" + event.total);
        }
      }
    }
  }

  // invoked when the input field has changed and new files have been dropped
  // or selected
  function change(event, opts) {
    event.preventDefault();

    // get all files ...
    var files = event.target.files;

    for (var i = 0; i < files.length; i++) {
      uploadStack.push(files[i]);
    }
    // ... and upload them
    uploadFiles(opts);
  }

})(jQuery);

// *******************************
// include script automation.js
function AutomationWrapper(operationId, opts) {
  this.operationId = operationId;
  this.opts = opts;
  this.headers = {};
}

AutomationWrapper.prototype.addParameter = function(name, value){
  this.opts.automationParams.params[name]=value;
  return this;
};

AutomationWrapper.prototype.addParameters = function(params){
  jQuery.extend(this.opts.automationParams.params,params);
  return this;
};

AutomationWrapper.prototype.context = function(name, value){
  this.opts.automationParams.context[name]=value;
  return this;
};

AutomationWrapper.prototype.setContext = function(ctxParams){
  jQuery.extend(this.opts.automationParams.context, ctxParams);
  return this;
};

AutomationWrapper.prototype.setTimeout = function(timeout){
  this.opts.execTimeout=timeout;
  return this;
};

AutomationWrapper.prototype.setHeaders = function(headers){
  jQuery.extend(this.headers, headers);
  return this;
};

AutomationWrapper.prototype.execute = function(successCB, failureCB, voidOp){
  var targetUrl = this.opts.url;
  if (targetUrl.indexOf("/", targetUrl.length - 1)==-1) {
    targetUrl = targetUrl + "/";
  }
  targetUrl =  targetUrl + this.operationId;

  if (!voidOp) {
    voidOp=false;
  }
  var timeout = 5+ (this.opts.execTimeout/1000)|0;
  var documentSchemas = this.opts.documentSchemas;
  var repo = this.opts.repository;
  var self = this;
  jQuery.ajax({
      type: 'POST',
      contentType : 'application/json+nxrequest',
      data: JSON.stringify(this.opts.automationParams),
      beforeSend : function (xhr) {
          xhr.setRequestHeader('X-NXVoidOperation', voidOp);
          xhr.setRequestHeader('Nuxeo-Transaction-Timeout', timeout);
          if (documentSchemas.length>0) {
              xhr.setRequestHeader('X-NXDocumentProperties',documentSchemas);
            }
          if (repo) {
              xhr.setRequestHeader('X-NXRepository', repo);
          }
          for (var key in self.headers) {
            xhr.setRequestHeader(key, self.headers[key]);
          }
      },
      url: targetUrl,
      timeout: this.opts.execTimeout,
      error: function(xhr, status, e) {
        if (failureCB) {
            failureCB(xhr,status,"No Data");
          } else {
            log("Failed to execute");
            log("Error, Status =" + status);
          }
      },
      success: function(data, status,xhr) {
        log("Executed OK");
        if (status=="success") {
          successCB(data,status,xhr);
        } else {
          if (failureCB) {
            failureCB(xhr,status,"No Data");
          } else {
            log("Error, Status =" + status);
          }
        }
      }
    })
};

AutomationWrapper.prototype.executeGetBlob = function(successCB, failureCB, blobOp){

    var targetUrl = this.opts.url;
    if (targetUrl.indexOf("/", targetUrl.length - 1)==-1) {
      targetUrl = targetUrl + "/";
    }
    targetUrl =  targetUrl + this.operationId;

    if (!blobOp) {
      voidOp=false;
    }
    var timeout = 5+ (this.opts.execTimeout/1000)|0;
    var documentSchemas = this.opts.documentSchemas;
    var repo = this.opts.repository;
    jQuery.ajax({
        type: 'POST',
        contentType : 'application/json+nxrequest',
        data: JSON.stringify(this.opts.automationParams),
        beforeSend : function (xhr) {
            xhr.setRequestHeader('CTYPE_MULTIPART_MIXED', blobOp);
            xhr.setRequestHeader('Nuxeo-Transaction-Timeout', timeout);
            if (documentSchemas.length>0) {
              xhr.setRequestHeader('X-NXDocumentProperties',documentSchemas);
            }
            if (repo) {
                xhr.setRequestHeader('X-NXRepository', repo);
            }
        },
        url: targetUrl,
        timeout: this.opts.execTimeout,
        error: function(xhr, status, e) {
          if (failureCB) {
              failureCB(xhr,status,"No Data");
            } else {
              log("Failed to execute");
              log("Error, Status =" + status);
            }
        },
        success: function(data, status,xhr) {
          log("Executed OK");
          if (status=="success") {
            successCB(data,status,xhr);
          } else {
            if (failureCB) {
              failureCB(xhr,status,"No Data");
            } else {
              log("Error, Status =" + status);
            }
          }
        }
      })
 };

AutomationWrapper.prototype.log = function (msg) {
  if (window.console) {
      //console.log(msg);
    }
};

AutomationWrapper.prototype.batchExecute = function(batchId, successCB, failureCB, voidOp){

  if (!voidOp) {
    voidOp=false;
  }
  this.addParameter("operationId", this.operationId);
  this.addParameter("batchId", batchId);

  var targetUrl = this.opts.url;
  var targetUrl = this.opts.url;
  if (targetUrl.indexOf("/", targetUrl.length - 1)==-1) {
    targetUrl = targetUrl + "/";
  }
  if (targetUrl.indexOf('/batch/execute')<0) {
    targetUrl = targetUrl + 'batch/execute';
  }
  var timeout = 5+ (this.opts.execTimeout/1000)|0;
  var documentSchemas = this.opts.documentSchemas;
  var repo = this.opts.repository;
  jQuery.ajax({
      type: 'POST',
      contentType : 'application/json+nxrequest',
      data: JSON.stringify(this.opts.automationParams),
      beforeSend : function (xhr) {
          xhr.setRequestHeader('X-NXVoidOperation', voidOp);
          xhr.setRequestHeader('Nuxeo-Transaction-Timeout', timeout);
          if (documentSchemas.length>0) {
              xhr.setRequestHeader('X-NXDocumentProperties',documentSchemas);
          }
          if (repo) {
              xhr.setRequestHeader('X-NXRepository', repo);
          }
      },
      url: targetUrl,
      timeout: this.opts.execTimeout,
      error: function(xhr, status, e) {
        log("Failed to execute");
        if (failureCB) {
          var errorMessage = null;
          if (xhr.response) {
            errorMessage =xhr.response;
            var parsedError = errorMessage;
            try {
              parsedError = JSON.parse(errorMessage);
              errorMessage = parsedError.error
            } catch (err) {
              // NOP
            }
          }
          failureCB(xhr,status,errorMessage);
        } else {
            log("Error, Status =" + status);
        }
      },
      success: function(data, status,xhr) {
        log("Executed OK : " + status);
        if (status=="success") {
          successCB(data,status,xhr);
        } else {
          console.log
            if (failureCB) {
                failureCB(xhr,status,"No Data");
              } else {
                log("Error, Status =" + status);
              }
        }
      }
    })
  };

(function($) {

   $.fn.automation = function ( operationId , options) {
      var opts = jQuery.extend(true, {}, $.fn.automation.defaults, options);
      return new AutomationWrapper(operationId, opts);
   }

   $.fn.automation.defaults = {
        url : nxContextPath + "/site/automation",
        execTimeout : 30000,
        uploadTimeout : 30000,
        documentSchemas : "dublincore",
        automationParams : {
           params : {},
           context : {}
       }
   }

 })(jQuery);

// *******************************
// include script dnd/nxdropzone.js
// ********************************************************
// Provides a JQuery wrapper to initialize Drop zones
// JQuery dropzone object is linked to a UIControler object
// that manages dialog

// some helper functcions

function log(msg) {
  if (window.console) {
    //console.log(msg);
  }
}

function logError(msg) {
  if (window.console) {
    //console.error(msg);
  }
}

function getReadableSpeedString(speedInKBytesPerSec) {
  var speed = speedInKBytesPerSec;
  speed = Math.round(speed * 10) / 10;
  if (speed < 1024) {
    return speed + "KB/s";
  }

  speed /= 1024;
  speed = Math.round(speed * 10) / 10;
  return speed + "MB/s";
}

function getReadableFileSizeString(fileSizeInBytes) {
  var fileSize = fileSizeInBytes;
  if (fileSize < 1024) {
    return fileSize + "B";
  }

  fileSize /= 1024;
  fileSize = Math.round(fileSize);
  if (fileSize < 1024) {
    return fileSize + "KB";
  }

  fileSize /= 1024;
  fileSize = Math.round(fileSize * 10) / 10;
  if (fileSize < 1024) {
    return fileSize + "MB";
  }

  return fileSizeInBytes + "B";
}

function getReadableDurationString(duration) {
  var minutes, seconds;

  seconds = Math.floor(duration / 1000);
  minutes = Math.floor((seconds / 60));
  seconds = seconds - (minutes * 60);

  var str = "";
  if (minutes > 0)
    str += minutes + "m";

  str += seconds + "s";
  return str;
}

//****************************
// UI Handler
// contains UI related methods and CallBacks
function DropZoneUIHandler(idx, dropZoneId, options, targetSelectedCB, cancelCB) {

  this.idx = idx;
  this.dropZoneId = dropZoneId;
  this.batchId = null;
  this.nxUploaded = 0;
  this.nxUploadStarted = 0;
  this.url = options.url;
  this.ctx = options.dropContext;
  this.operationsDef = null;
  this.uploadedFiles = [];
  this.targetSelectedCB = targetSelectedCB;
  this.cancelled = false;
  this.extendedMode = false;
  this.executionPending = false;
  this.opts = options;
  this.cancelCB = cancelCB;
}

DropZoneUIHandler.prototype.uploadStarted = function (fileIndex, file) {
  this.nxUploadStarted++;

  jQuery("#dndMsgUploadInProgress").css("display", "block");
  jQuery("#dndMsgUploadCompleted").css("display", "none");

  // UI Display
  var infoDiv = jQuery("<div></div>");
  infoDiv.addClass("dropzone-info-name");
  infoDiv.attr("id", "dropzone-info-" + this.idx + "-" + fileIndex);
  infoDiv.html(file.name);

  var progressDiv = jQuery("<div></div>");
  progressDiv.addClass("dropzone-info-progress");
  progressDiv.attr("id", "dropzone-speed-" + this.idx + "-" + fileIndex);

  var fileDiv = jQuery("<div></div>");
  fileDiv.addClass("dropzone-info-item");
  fileDiv.attr("id", "dropzone-info-item-" + this.idx + "-" + fileIndex);
  fileDiv.append(infoDiv);
  fileDiv.append(progressDiv);

  jQuery("#dropzone-info").after(fileDiv);
};

DropZoneUIHandler.prototype.uploadFinished = function (fileIndex, file, duration) {
  jQuery("#dropzone-info-item-" + this.idx + "-" + fileIndex).css("display", "none");
  var fileDiv = jQuery("<div></div>");
  fileDiv.addClass("dropzone-info-summary-item");
  fileDiv.html(file.name + " (" + getReadableFileSizeString(file.size) + ") in " + (getReadableDurationString(duration)));
  jQuery("#dropzone-info-summary").append(fileDiv);
  this.nxUploaded++;
  this.uploadedFiles.push(file);
  jQuery("#dropzone-bar-msg").html(this.nxUploaded + "/" + this.nxUploadStarted);
};

DropZoneUIHandler.prototype.fileUploadProgressUpdated = function (fileIndex, file, newProgress) {
  jQuery("#dropzone-speed-" + this.idx + "-" + fileIndex).css("width", newProgress + "%");
};

DropZoneUIHandler.prototype.fileUploadSpeedUpdated = function (fileIndex, file, KBperSecond) {
  var dive = jQuery("#dropzone-speed-" + this.idx + "-" + fileIndex);
  dive.html(getReadableSpeedString(KBperSecond));
};

DropZoneUIHandler.prototype.selectTargetZone = function () {
  var dzone = jQuery("#" + this.dropZoneId); // XXX
  dzone.addClass("dropzoneTarget");
  this.targetSelectedCB(this.dropZoneId);
};

DropZoneUIHandler.prototype.fetchOptions = function () {
  log("Fetching options");
  var handler = this; // deRef object !
  var context = jQuery("#" + this.dropZoneId).attr("context");
  // Fetch the import options
  var getOptions;
  if (this.ctx.conversationId) {
    getOptions = jQuery().automation('Chain.SeamActions.GET');
  } else {
    getOptions = jQuery().automation('Actions.GET');
  }
  getOptions.addParameter("category", context);
  getOptions.setContext(this.ctx);
  getOptions.execute(
    function (data, textStatus, xhr) {
      if (data.length == 0) {
        handler.operationsDef = null;
        handler.canNotUpload(false, true);
        return;
      }
      handler.operationsDef = data;
      for (var i = 0; i < handler.operationsDef.length; i++) {
        var chainOrOperationId = null;
        if (handler.operationsDef[i].properties.chainId !== undefined) {
          chainOrOperationId = handler.operationsDef[i].properties.chainId;
        } else if (handler.operationsDef[i].properties.operationId !== undefined) {
          chainOrOperationId = handler.operationsDef[i].properties.operationId;
        } else {
          chainOrOperationId = handler.operationsDef[i].id;
        }
        handler.operationsDef[i].chainOrOperationId = chainOrOperationId;
      }
      if (handler.executionPending) {
        // execution was waiting for the op definitions
        handler.executionPending = false;
        handler.selectOperation(handler.batchId, handler.dropZoneId, handler.url);
      }
    },
    function (xhr, status, e) {
      log(e);
      handler.canNotUpload(true, false);
    }, false);
};

DropZoneUIHandler.prototype.canNotUpload = function (isError, noop) {
  this.cancelUpload();
  if (isError) {
    alert(jQuery("#dndErrorMessage").html());
  } else if (noop) {
    alert(jQuery("#dndMessageNoOperation").html());
  }
  window.location.reload(true);
};

DropZoneUIHandler.prototype.cancelUpload = function () {
  this.cancelled = true;
  jQuery("#dndContinueButton").css("display", "none");
  jQuery("#dropzone-info-panel").css("display", "none");
  jQuery(".dropzoneTargetOverlay").remove();
  var dzone = jQuery("#" + this.dropZoneId);
  dzone.removeClass("dropzoneTarget");
  dzone.removeClass("dropzoneTargetExtended");
  var dragoverTimer = dzone.data("dragoverTimer");
  if (dragoverTimer) {
    window.clearTimeout(dragoverTimer);
    dzone.removeData("dragoverTimer");
  }
  this.cancelCB();
  if (this.batchId) {
    var targetUrl = this.url + 'batch/drop/' + this.batchId;
    jQuery.ajax({
      type: 'GET',
      contentType: 'application/json+nxrequest',
      url: targetUrl,
      timeout: 10000});
  }
};

DropZoneUIHandler.prototype.batchStarted = function () {
  this.cancelled = false;
  if (this.batchId == null) {
    // select the target DropZone
    this.selectTargetZone();
    // generate a batchId
    this.batchId = "batch-" + new Date().getTime() + "-" + Math.floor(Math.random() * 1000);
    // fetch import options
    this.fetchOptions();
  }
  // Add the status bar on top of body
  var panel = jQuery("#dropzone-info-panel");
  panel.css({ position: 'absolute', left: '30%', top: '30%' });
  //panel.css("width",jQuery("body").width()-100);
  panel.css("display", "block");
  jQuery("#dndMsgUploadInProgress").css("display", "block");
  jQuery("#dndMsgUploadCompleted").css("display", "none");
  jQuery("#dropzone-bar-msg").html("...");
  jQuery("#dropzone-bar-btn").css("visibility", "hidden");

  return this.batchId;
};

DropZoneUIHandler.prototype.batchFinished = function (batchId) {
  if (!this.cancelled) {
    if (this.extendedMode) {
      this.showContinue(batchId);
    } else {
      this.selectOperation(this.batchId, this.dropZoneId, this.url);
    }
  } else {
    this.cancelled = false;
  }
};

DropZoneUIHandler.prototype.positionContinueButton = function () {
  // Show the continue button at center of dropzone
  var continueButton = jQuery("#dndContinueButton");
  continueButton.css("position", "absolute");
  continueButton.css("display", "block");
  continueButton.css("z-index", "5000");
  var zone = jQuery("#" + this.dropZoneId);
  var btnPosition = zone.position();
  btnPosition.top = btnPosition.top + zone.height() / 2 - continueButton.height() / 2;
  btnPosition.left = btnPosition.left + zone.width() / 2 - continueButton.width() / 2;
  continueButton.css(btnPosition);
  return continueButton
};


DropZoneUIHandler.prototype.showContinue = function (batchId) {
  // Show the continue button in bar
  jQuery("#dndMsgUploadInProgress").css("display", "none");
  jQuery("#dndMsgUploadCompleted").css("display", "block");
  var continueButtonInBar = jQuery("#dropzone-bar-btn");
  continueButtonInBar.css("visibility", "visible");
  continueButtonInBar.attr("value", "Continue");

  // Show the continue button at center of dropzone
  var continueButton = this.positionContinueButton();

  // bind click
  var handler = this; // deRef object !
  continueButtonInBar.unbind();
  continueButtonInBar.bind("click", function (event) {
    handler.selectOperation(batchId, handler.dropZoneId, handler.url)
  });
  continueButton.unbind();
  continueButton.bind("click", function (event) {
    continueButton.css("display", "none");
    handler.selectOperation(batchId, handler.dropZoneId, handler.url)
  });
};

DropZoneUIHandler.prototype.updateForm = function (event, value) {
  log("updateForm: " + value);
  for (var i = 0; i < this.operationsDef.length; i++) {
    if (this.operationsDef[i].chainOrOperationId == value) {
      var desc = jQuery("<div></div>");
      desc.html(this.operationsDef[i].help + "<br/>");
      jQuery("#dndSubForm").html(desc);
      if (this.operationsDef[i].link != '') {
        jQuery("#dndFormSubmitButton").css("display", "none");
        var iframe = jQuery("<iframe></iframe>");
        iframe.attr("width", "400px");
        iframe.attr("height", "550px");
        iframe.attr("frameborder", "0");
        var src = this.operationsDef[i].link;
        if (src.indexOf("?") != -1) {
          src += "&conversationId=" + currentConversationId;
        } else {
          src += "?conversationId=" + currentConversationId;
        }
        iframe.attr("src", src);
        desc.append(iframe);
        var handler = this;
        window.dndFormFunctionCB = function (fData) {
          handler.executeBatch(value, fData);
        };
      } else {
        jQuery("#dndFormSubmitButton").css("display", "block");
      }
      break;
    }
  }
  var panel = jQuery("#dndFormPanel");
  var body = jQuery("body");
  var panelPosition = body.position();
  body.append(panel);
  if (panel.width() > 0.8 * body.width()) {
    panel.css("width", 0.8 * body.width());
  }
  panelPosition.top = panelPosition.top + jQuery(window).height() / 2 - panel.height() / 2 + jQuery(window).scrollTop();
  panelPosition.left = panelPosition.left + body.width() / 2 - panel.width() / 2;
  if (panelPosition.top < 10) {
    panelPosition.top = 10;
  }
  if (panelPosition.left < 10) {
    panelPosition.left = 10;
  }

  panel.css(panelPosition);
};

DropZoneUIHandler.prototype.selectOperation = function (batchId, dropId, url) {
  var o = this, // deRef object !
    i;

  jQuery("#dropzone-info-panel").css("display", "none");


  log(this.operationsDef);
  if (this.operationsDef == null) {
    this.executionPending = true;
    log("No OpDEf found !!!");
    return;
  } else {
    if ((this.extendedMode == false || this.operationsDef.length == 1)
      && this.operationsDef[0].link == '') {
      this.executeBatch(this.operationsDef[0].chainOrOperationId, {});
      return;
    }
  }

  // Build the form
  log("build form");
  var panel = jQuery("#dndFormPanel");

  // update the file list
  var fileList = jQuery("#uploadedFileList");
  fileList.html("");
  for (i = 0; i < this.uploadedFiles.length; i++) {
    var fileItem = jQuery("<div></div>");
    var file = this.uploadedFiles[i];
    fileItem.html(file.name + " (" + getReadableFileSizeString(file.size) + ")");
    fileList.append(fileItem);
  }

  // fill the selector
  var selector = jQuery("#operationIdSelector");
  selector.html("");
  for (i = 0; i < this.operationsDef.length; i++) {
    var optionEntry = jQuery("<option></option>");
    optionEntry.attr("value", this.operationsDef[i].chainOrOperationId);
    optionEntry.text(this.operationsDef[i].label);
    selector.append(optionEntry);
  }
  selector.unbind();
  selector.bind("change", function (event) {
    o.updateForm(event, selector.val())
  });
  var buttonForm = jQuery("#dndFormSubmitButton");

  panel.css("z-index", "5000");
  panel.css("display", "block");
  this.updateForm(null, this.operationsDef[0].chainOrOperationId);

  buttonForm.unbind();
  buttonForm.bind("click", function (event) {
    // execute automation batch call
    var operationId = jQuery("#operationIdSelector").val();
    o.executeBatch(operationId, {});
  });
};

DropZoneUIHandler.prototype.executeBatch = function (operationId, params) {
  log("exec operation " + operationId + ", batchId=" + this.batchId);

  // hide the top panel
  jQuery("#dropzone-info-panel").css("display", "none");
  jQuery("#dndFormPanel").css("display", "none");

  // change the continue button to a loading anim
  var continueButton = this.positionContinueButton();
  continueButton.unbind();
  jQuery("#dndContinueButtonNext").css("display", "none");
  jQuery("#dndContinueButtonWait").css("display", "block");
  continueButton.css("display", "block");

  var batchExec = jQuery().automation(operationId, this.opts);
  log(this.ctx);
  batchExec.setContext(this.ctx);
  batchExec.setContext(params);
  log(batchExec);
  var cancelHandler = this;
  batchExec.batchExecute(this.batchId,
    function (data, status, xhr) {
      log("Import operation executed OK");
      window.location.reload(true);
      log("refresh-done");
    },
    function (xhr, status, errorMessage) {
      cancelHandler.cancelUpload();
      if (status == "timeout") {
        alert(jQuery("#dndTimeoutMessage").html());
      } else if (xhr.readyState != 4) {
        alert(jQuery("#dndNoResponseMessage").html());
      } else {
        if (xhr.status == 403) {
          alert(jQuery("#dndSecurityErrorMessage").html());
          logError(errorMessage);
        } else {
          if (errorMessage && errorMessage != 'null') {
            alert(jQuery("#dndServerErrorMessage").html());
            logError(errorMessage);
          } else {
            alert(jQuery("#dndUnknownErrorMessage").html());
          }
        }
      }
      window.location.reload(true);
    },
    true
  );
};

DropZoneUIHandler.prototype.enableExtendedMode = function (dropId) {
  this.extendedMode = true;
  jQuery("#" + dropId).addClass('dropzoneTargetExtended');
};

DropZoneUIHandler.prototype.removeDropPanel = function (dropId, batchId) {
  var dropPanel = jQuery("#dropPanel-" + this.idx);
  dropPanel.after(jQuery("#" + dropId));
  dropPanel.remove();
  this.batchId = null;
  this.nxUploaded = 0;
  this.nxUploadStarted = 0;
};
// ******************************


// ******************************
// Global vars (may be stored in JQuery data on the body ?

var NXDropZone = {
  handlerIdx: 0,
  highLightOn: false,
  targetSelected: false,
  initDone: false
};


// ******************************
// JQuery binding

(function ($) {
  // reinitialize NXDropZone object state
  NXDropZone.handlerIdx = 0;
  NXDropZone.highLightOn = false;
  NXDropZone.targetSelected = false;
  NXDropZone.initDone = false;

  $.fn.nxDropZone = function (options) {
    // reinitialize NXDropZone object state
    NXDropZone.handlerIdx = 0;
    NXDropZone.highLightOn = false;
    NXDropZone.targetSelected = false;
    NXDropZone.initDone = false;

    var ids = [];
    this.each(function () {
      var dropZone = jQuery(this);
      var dropId = dropZone.attr("id");
      ids.push(dropId);
      // only get the ids
      // real underlying object will be initialized when needed
      // to avoid any clash with other DnD features ...

      if (!NXDropZone.initDone && dropZone.data("loadalreadyuploadedfiles")) {
        highlightDropZones(null, ids, options, dropId);
      }
    });

    // bind events on body to show the drop box
    document.body.ondragover = function (event) {
      highlightDropZones(event, ids, options)
    };
    document.body.ondragleave = function (event) {
      removeHighlights(event, ids)
    };
    document.body.ondrop = function (event) {
      var dt = event.dataTransfer;
      if (dt && dt.files != null && dt.files.length == 0) {
        jQuery.each(ids, function (idx, id) {
          var dzone = jQuery("#" + id);
          dzone.removeClass("dropzoneTarget");
          dzone.removeClass("dropzoneTargetExtended");
          var dragoverTimer = dzone.data("dragoverTimer");
          if (dragoverTimer) {
            window.clearTimeout(dragoverTimer);
            dzone.removeData("dragoverTimer");
          }
        });
      }
    };
  };

  function isFileDndEvent(event) {
    var dt = event.dataTransfer;
    if (!dt && event.originalEvent) {
      // JQuery event wrapper
      dt = event.originalEvent.dataTransfer;
    }
    if (dt && dt.types != null && dt.types.length != null) {
      if (dt.types.indexOf && dt.types.indexOf("Files") > -1) {
        return true;
      }
      if (dt.types.contains && dt.types.contains("Files")) {
        // in Firefox 4 dt.types is a DOMStringList
        return true;
      }
    }
    return false;
  }

  function highlightDropZones(event, ids, options, dropZoneId) {

    function targetSelect(targetId) {
      NXDropZone.targetSelected = true;
      jQuery.each(ids, function (idx, id) {
        var ele = jQuery("#" + id);
        if (id != targetId) {
          ele.unbind();
        }
        ele.unbind('dragleave');
      });
    }

    function cancel() {
      NXDropZone.highLightOn = true;
      NXDropZone.initDone = false;
      removeHighlights(null, ids)
    }

    function initDropZone(id, loadAlreadyUploadedFiles) {
      if (!NXDropZone.initDone) {
        var ele = jQuery("#" + id);
        var handlerFunc = options.handler || DropZoneUIHandler;
        var uiHandler = new handlerFunc(NXDropZone.handlerIdx++, id, options, targetSelect, cancel);
        // copy optionMap
        var instanceOptions = jQuery.extend({}, options);
        // register callback Handler
        instanceOptions.handler = uiHandler;
        log("Init Drop zone " + id);
        ele.dropzone(instanceOptions, loadAlreadyUploadedFiles);
        ele.addClass("dropzoneHL");
      }
    }

    if (NXDropZone.highLightOn || NXDropZone.targetSelected) {
      return;
    }

    if (dropZoneId !== undefined) {
      initDropZone(dropZoneId, true);
      NXDropZone.initDone = true;
      NXDropZone.highLightOn = true;
      return;
    }

    if (isFileDndEvent(event)) {
      jQuery.each(ids, function (idx, id) {
        initDropZone(id);
      });
      NXDropZone.initDone = true;
      NXDropZone.highLightOn = true;
    }
  }

  function removeHighlights(event, ids) {
    if (!NXDropZone.highLightOn || NXDropZone.targetSelected) {
      return;
    }
    jQuery.each(ids, function (idx, id) {
      jQuery("#" + id).removeClass("dropzoneHL");
    });
    NXDropZone.highLightOn = false;
  }

})(jQuery);

// *******************************
// include script dnd/nxdropout.js
// ************************************************
// Simple JQuery plugin to enable Drag out of files

(function($) {
   $.fn.dropout = function ( baseUrl , repo ) {
      for (i=0; i< this.length; i++) {
          var target = $(this[i]);
          var id = target.attr("id");
          var docRef = target.attr("docRef");
          if (docRef==null) {
          var url = target.attr("downloadUrl");
          var mt = target.attr("mimetype");
          var filename = target.attr("filename");
          if (url!=null && mt!=null && filename!=null) {
            target.attr("draggable", "true");
            target.bind("dragstart", getDirectDownloadInfo(url,mt,filename));
            } else {
              //console.log("no download info found!!!");
            }
          } else {
            var url = baseUrl + "nxdownloadinfo/" + repo + "/" + docRef;
            target.attr("draggable", "true");
            target.bind("dragstart", getDownloadInfoFetcher(url));
          }
        }
   }

   // using to function returning a function to force closure !
   function  getDirectDownloadInfo(url,mt,filename) {
       var downloadURL = mt + ":" + filename + ":" + url;
       return function(event) {
             event.originalEvent.dataTransfer.setData("DownloadURL", downloadURL);
       };
     }

   function  getDownloadInfoFetcher(url) {
     return function(event) {
           //console.log("dropout");
           jQuery.ajax({
             async: false,
             complete: function(data) {
               event.originalEvent.dataTransfer.setData("DownloadURL", data.responseText);
               },
             error: function(xhr) {
               if (xhr.status == 404) {
                 xhr.abort();
               }
             },
             type: 'GET',
             timeout: 3000,
             url: url
           });

           event.stopPropagation();
           };
   }
})(jQuery);



// *******************************
// include script dnd/nxinternaldnd.js
//***************************************************************
// JQuery wrapper to initialize internal (Prototype based)  Dnd

(function($) {

   $.fn.nxInitDraggables = function ( options ) {
     this.each(makeDraggable);
   }

   function makeDraggable() {
     var target = jQuery(this);
     //console.log("makeDraggable :" + target.attr('id'));
     new Draggable(target.attr('id'),{revert:true});
   }

   $.fn.nxInitDropTargets = function ( options ) {
     this.each(makeDropTarget);
   }

   function makeDropTarget() {
    var target = jQuery(this);
    var targetId=target.attr('id');
    var refId = targetId.replace('docRefTarget','docRef');
    if (targetId.indexOf('nodeRefTarget')==0) {
      refId = targetId.replace('nodeRefTarget','docRef');
    }
    //console.log("makeDropTarget :" + targetId + " " + refId);
    Droppables.add(targetId, {
      accept:'cell',
      onDrop:function(element)
        {moveElement(element,refId);},
      hoverclass:'dropInto'});
   }
 })(jQuery);

